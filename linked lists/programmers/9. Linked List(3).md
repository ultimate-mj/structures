## 연결 리스트가 힘을 발휘할 때

ex) 스마트폰에서 여러 창을 띄워놓고 추가하거나 뺄 때 유용

- 삽입과 삭제가 유연함
- 그런데: 지금까지 본 코드는 n번째를 찾아가야 하기 때문에 부담이 됨
 
-> 새로운 메소드를 만들자!!
- insertAfter(prev, newNode): 위치를 주는 것이 아니라, 어떤 노드를 주고 그 뒤에 삽입해라
- popAfter(prev): 어떤 노드를 주고 그 뒤의 것을 삭제해라
  + 맨 앞에는 어떻게 하지?? 
  + **dummy node**를 추가하자!
```
head ---> 67 ---> 34 ----> 58
```

```python
class LinkedList:
    def __init__(self):
        self.nodeCount = 0
        self.head = Node(None)  #dummy node
        self.tail = None
        self.head.next = self.tail
```

## 연산 정의
(이제 dummy node가 추가된 코드로)
1. 특정 원소 참조 (k 번째)
2. 리스트 순회 
3. 길이 얻어내기
4. 원소 삽입
5. 원소 삭제
6. 두 리스트 합치기

### 2. 리스트 순회

```python
#리스트 순회
def traverse(self):
    result = []
    curr = self.head
    while curr.next:   #다음 노드가 있다면
        curr = curr.next
        result.append(curr.data)
    return result
```

### 1. k번째 원소 얻어내기

```python
def getAt(self, pos):
    if pos < 0 or pos > self.nodeCount:   #pos < 1 보다 간편, 일반화하기 쉬움
        return None
    i = 0  #1이 아니라 0부터 시작!
    curr = self.head
    while i < pos:
        curr = curr.next
        i += 1
    return curr
```

### 4. 원소 삽입

- 코드 구현 순서:
1. prev가 가리키는 노드의 다음에
2. newNode를 삽입하고
3. 성공/실패에 따라 True/False를 리턴

