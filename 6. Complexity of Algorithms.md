## 알고리즘의 복잡도
: 시간적, 공간적 자원을 얼마나 소요하는가
- 시간 복잡도 (Time complexity): 문제의 크기와 이를 해결하는 데에 걸리는 시간 사이의 관계
- 공간 복잡도 (Space complexity): 문제의 크기와 이를 해결하는 데에 필요한 메모리 공간 사이의 관계
- 시간 복잡도 위주로 살펴볼 것

#### 시간 복잡도
- 평균 시간 복잡도 (Average time complexity): 임의의(random) 입력 패턴을 가정했을 때 소요되는 시간의 평균
- 최악 시간 복잡도 (Worst-case time complexity): 가장 긴 시간을 소요하게 만드는 입력에 따라 소요되는 시간

#### Big-O Notation
: 점근 표기법 (asymptotic notation)의 하나
- 어떤 함수의 증가 양상을 다른 함수와의 비교로 표현
- 알고리즘의 복잡도를 표현할 때 흔히 쓰임
- ex) $O(n^2)$: O of n square 일 때, $n^2$에 비례하는 시간 소요
- 계수는 그다지 중요하지 않음

#### 선형 시간 알고리즘 - $O(n)$
ex) n개의 무작위로 나열된 수에서 최댓값을 찾는 선형 탐색 알고리즘
- average case: $O(n)$
- worst case: $O(n)$

#### 로그 시간 알고리즘 - $O(logn)$
ex) n개의 크기 순으로 정렬된 수에서 특정 값을 찾기 위해 이진 탐색 알고리즘 적용

#### 이차 시간 알고리즘 - $O(n^2)$
ex) 삽입 정렬 (insertion sort): 앞에서부터 하나씩 정렬 (n개와 비교하는 삽입 정렬을 n개의 원소에 대해 실행해야 함)
- best case: $O(n)$ (다 정렬된 상태라면)
- worst case: $O(n^2)$ (역순으로 정렬된 상태라면)

## 가장 낮은 복잡도를 가지는 정렬 알고리즘
: 병합 정렬 (merge sort) - $O(nlogn)$
- 입력 패턴에 따라 정렬 속도에 차이가 있지만 정렬 문제에 대해 이보다 낮은 복잡도를 갖는 알고리즘은 존재할 수 없음이 증명되어 있음

#### 병합 정렬 알고리즘
: 데이터를 반씩 나누어 각각을 정렬시킨 후 순서대로 합치기
- 정렬할 데이터를 반씩 나누어 각각을 정렬시킴 - $O(logn)$
- 정렬된 데이터를 두 묶음씩 합침 - $O(n)$
- 나누고 합치는 복잡도를 더하면 $O(nlogn)$ 이 됨

## 보다 복잡한 문제
#### 배낭 문제 (Knapsack problem)
: $x$ kg를 담을 수 있는 가방에 각기 다른 무게와 가격을 가진 물건들들 중 어떤 것을 넣어야 가장 높은 가치를 가지게 되는지
- 하나씩 넣고 빼는 경우의 수 - $O(2^n)$
