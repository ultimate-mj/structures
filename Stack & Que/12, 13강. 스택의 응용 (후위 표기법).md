# 스택의 응용 (수식의 후위 표기법)
1. 중위 표기법 (infix notation): 연산자가 피연산자들의 **사이**에 위치
- ex) (A+B) * (C+D)  : A+B -> C+D -> *

2. 후위 표기법 (postfix notation): 연산자가 피연산자들의 **뒤**에 위치
- ex) AB + CD + *  : A+B -> C+D -> * : 순서대로 계산하게 되고 괄호가 필요 없음


## 중위 표현식 -> 후위 표현식

```
1. [중위] A * B + C       [후위] A B * C +

2. [중위] A + B * C       [후위] A B C * +

3. [중위] A + B + C       [후위] A B + C +
  
4. [중위] ( A + B ) * C   [후위] A B + C *

5. [중위] A * ( B + C )   [후위] A B C + *
```

1번 예시의 알고리즘 순서:
- 중위에서 A: 후위에 A 저장
- 연산자 * : 스택에 * 넣기
- 중위에서 B: 후위에 B 저장
- 연산자 + : 스택의 꼭대기에 들어 있는 연산자인 * 와 비교 -> * 를 먼저 계산해야 하므로 pop 해서 B 뒤에 넣기 -> 스택에 + 넣기
- 중위에서 C: 후위에 C 저장
- 수식이 끝남, 스택에 남아있는 +를 후위에 저장

2번 예시의 알고리즘 순서:
- 중위에서 A: 후위에 A 저장
- 연산자 + : 스택에 + 넣기
- 중위에서 B: 후위에 B 저장
- 연산자 * : 스택의 꼭대기에 들어 있는 연산자인 + 와 비교 -> * 를 먼저 계산해야 하므로 스택 제일 위에 * 를 넣기 (꺼낼 때는 위에 있는 연산자 먼저 나옴)
- 중위에서 C: 후위에 C 저장
- 수식이 끝남, 스택에 남아있는 연산자를 하나씩 pop

3번 예시의 알고리즘 순서:
- 중위에서 A: 후위에 A 저장
- 연산자 + : 스택에 + 넣기
- 중위에서 B: 후위에 B 저장
- 연산자 + : 스택의 꼭대기에 들어 있는 연산자인 + 와 비교 -> 동일한 우선순위이므로 스택에 있는 + 를 pop해서 B 뒤에 넣고 -> 스택에 + 넣기
- 중위에서 C: 후위에 C 저장
- 수식이 끝남, 스택에 남아있는 + 를 pop

4번 예시의 알고리즘 순서:
- point: 괄호의 우선순위를 제일로 해야 함
 + 여는 괄호는 스택에 push
 + 닫는 괄호를 만나면 여는 괄호가 나올 때까지 pop

5번 예시의 알고리즘 순서:
- point: 연산자를 만났을 때, 여는 괄호 너머까지 pop하지 않도록 여는 괄호의 우선순위는 가장 낮게 설정
```
+
(
*
``` 

### 예제

```
1. [중위] ( A + B ) * ( C + D )       [후위] A B + C D + *

2. [중위] ( A + ( B - C ) ) * D       [후위] A B C - + D *

3. [중위] A * ( B - ( C + D ) )       [후위] A B C D + - *
```

## 알고리즘의 설계

연산자의 우선순위 설정
```python
#precedence
prec = {
    '*': 3, '/': 3,
    '+': 2, '-': 2,
    '(': 1
}
```

중위 표현식을 왼쪽부터 한 글자씩 읽어서
- 피연산자이면 그냥 출력
- '('이면 스택에 push
- ')'이면 '('이 나올 때까지 스택에서 pop, 출력
- 연산자이면 스택에서 이보다 높(거나 같)은 우선순위 것들을 pop, 출력
  + 그리고 이 연산자는 스택에 push
- 스택에 남아 있는 연산자는 모두 pop, 출력


## 연습문제

힌트
- 스택의 맨 위에 있는 연산자와의 우선순위 비교: `peek()` 연산 이용
- 스택에 남아 있는 연산자 모두 pop() 하는 순환문: `while not opStack.isEmpty():`

### My Solution 1. list index out of range 오류

```python
def solution(S):
    opStack = ArrayStack()
    answer = ''
    
    match = {
        ')': '(', 
        '}': '{', 
        ']': '['
    }
    
    prec = {
        '*': 3, '/': 3,
        '+': 2, '-': 2,
        '(': 1
    }
    
    for c in S:
        if c in '({[':
            opStack.push(c)
        elif c in match:
            t = opStack.pop()
            while t != match[c]:
                answer + t
                t = opStack.pop()
        elif c in prec:
            t = opStack.peek()
            if prec[c] < prec[t]:
                answer + t
                opStack.pop()
                opStack.push(c)
            else:
                opStack.push(c)
        else:  #알파벳인 경우
            answer + c
    while not opStack.isEmpty():
        answer + opStack.pop()
    return answer
```

# 스택의 응용 (후위 표기 수식 계산)

- 연산자가 나오면 앞의 두 개 피연산자를 연산한다는 원리로 계산
- 계산 결과는 스택에 다시 넣기

## 알고리즘의 설계
후위 표현식을 왼쪽부터 한 글자씩 읽어서
- 피연산자이면 스택에 push
- 연산자를 만나면 스택에서 pop -> (1), 또 pop -> (2)
  + 연산 순서는 `(2) 연산자 (1)`: 이 결과를 스택에 push
  + 순서는 뺄셈이나 나눗셈에서 중요
- 수식의 끝에 도달하면 스택에서 pop: 이것이 계산 결과

### 예시
```
[중위 표기]  A B + C D + *
[후위 표기] (A + B) * (C + D)
```
알고리즘 순서:
- A를 스택에 push
- B를 스택에 push
- + 를 만남: B를 pop, A를 pop, 두 개를 계산하고 A+B의 결과를 스택에 push
- C를 스택에 push
- D를 스택에 push
- + 를 만남: D를 pop, C를 pop, 두 개를 계산하고 C+D의 결과를 스택에 push
- * 를 만남: A+B를 pop, C+D를 pop
- 수식이 끝남, 스택의 결과를 pop


