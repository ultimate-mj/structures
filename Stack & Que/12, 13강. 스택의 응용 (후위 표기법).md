# 스택의 응용 (수식의 후위 표기법)
1. 중위 표기법 (infix notation): 연산자가 피연산자들의 **사이**에 위치
- ex) (A+B) * (C+D)  : A+B -> C+D -> *

2. 후위 표기법 (postfix notation): 연산자가 피연산자들의 **뒤**에 위치
- ex) AB + CD + *  : A+B -> C+D -> * : 순서대로 계산하게 되고 괄호가 필요 없음


## 중위 표현식 -> 후위 표현식

```
1. [중위] A * B + C       [후위] A B * C +

2. [중위] A + B * C       [후위] A B C * +

3. [중위] A + B + C       [후위] A B + C +
  
4. [중위] ( A + B ) * C   [후위] A B + C *

5. [중위] A * ( B + C )   [후위] A B C + *
```

1번 예시의 알고리즘 순서:
- 중위에서 A: 후위에 A 저장
- 연산자 * : 스택에 * 넣기
- 중위에서 B: 후위에 B 저장
- 연산자 + : 스택의 꼭대기에 들어 있는 연산자인 * 와 비교 -> * 를 먼저 계산해야 하므로 pop 해서 B 뒤에 넣기 -> 스택에 + 넣기
- 중위에서 C: 후위에 C 저장
- 수식이 끝남, 스택에 남아있는 +를 후위에 저장

2번 예시의 알고리즘 순서:
- 중위에서 A: 후위에 A 저장
- 연산자 + : 스택에 + 넣기
- 중위에서 B: 후위에 B 저장
- 연산자 * : 스택의 꼭대기에 들어 있는 연산자인 + 와 비교 -> * 를 먼저 계산해야 하므로 스택 제일 위에 * 를 넣기 (꺼낼 때는 위에 있는 연산자 먼저 나옴)
- 중위에서 C: 후위에 C 저장
- 수식이 끝남, 스택에 남아있는 연산자를 하나씩 pop

3번 예시의 알고리즘 순서:
- 중위에서 A: 후위에 A 저장
- 연산자 + : 스택에 + 넣기
- 중위에서 B: 후위에 B 저장
- 연산자 + : 스택의 꼭대기에 들어 있는 연산자인 + 와 비교 -> 동일한 우선순위이므로 스택에 있는 + 를 pop해서 B 뒤에 넣고 -> 스택에 + 넣기
- 중위에서 C: 후위에 C 저장
- 수식이 끝남, 스택에 남아있는 + 를 pop

4번 예시의 알고리즘 순서:
- point: 괄호의 우선순위를 제일로 해야 함
 + 여는 괄호는 스택에 push
 + 닫는 괄호를 만나면 여는 괄호가 나올 때까지 pop

5번 예시의 알고리즘 순서:
- point: 연산자를 만났을 때, 여는 괄호 너머까지 pop하지 않도록 여는 괄호의 우선순위는 가장 낮게 설정
```
+
(
*
``` 

### 예제

```
1. [중위] ( A + B ) * ( C + D )       [후위] A B + C D + *

2. [중위] ( A + ( B - C ) ) * D       [후위] A B C - + D *

3. [중위] A * ( B - ( C + D ) )       [후위] A B C D + - *
```

## 알고리즘의 설계

연산자의 우선순위 설정
```python
#precedence
prec = {
    '*': 3, '/': 3,
    '+': 2, '-': 2,
    '(': 1
}
```

중위 표현식을 왼쪽부터 한 글자씩 읽어서
- 피연산자이면 그냥 출력
- '('이면 스택에 push
- ')'이면 '('이 나올 때까지 스택에서 pop, 출력
- 연산자이면 스택에서 이보다 높(거나 같)은 우선순위 것들을 pop, 출력
  + 그리고 이 연산자는 스택에 push
- 스택에 남아 있는 연산자는 모두 pop, 출력


## 연습문제

힌트
- 스택의 맨 위에 있는 연산자와의 우선순위 비교: `peek()` 연산 이용
- 스택에 남아 있는 연산자 모두 pop() 하는 순환문: `while not opStack.isEmpty():`

